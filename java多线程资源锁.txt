java多线程资源锁
    解决死锁问题
        锁消除
        多对象抢占
            wait与notify等待与通知机制
                sleep() 和 wait()的异同
            锁与同步synchronized线程同步
                对象
                    对对象进行加锁，在 JVM 中，对象在内存中分为三块区域：
                        对象头（Header）
                            Mark Word（标记字段）：用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等；它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化
                            Klass Point（类型指针）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
                        实例数据（InstanceData）
                        对齐填充（Padding）
                方法
                    flags: ACC_SYNCHRONIZED
                代码块
                    通过 monitorenter 和 monitorexit 实现的
                        每个monitor维护着一个记录着拥有次数的计数器。未被拥有的monitor的该计数器为0，当一个线程获得monitor（执行monitorenter）后，该计数器自增变为 1
                        当同一个线程再次获得该monitor的时候，计数器再次自增
                        当不同线程想要获得该monitor的时候，就会被阻塞
                        当同一个线程释放 monitor（执行monitorexit指令）的时候，计数器再自减。当计数器为0的时候，monitor将被释放，其他线程便可以获得monitor
                        以前一直说是重量级，现在锁升级
                            重锁
                                内核态和用户态的切换（线程的等待唤起过程），大量系统资源消耗
                            被优化了，1.6为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁
                            针对 synchronized 获取锁的方式，JVM 使用了锁升级的优化方式，就是先使用偏向锁优先同一线程然后再次获取锁，如果失败，就升级为 CAS 轻量级锁，如果失败就会短暂自旋，防止线程被系统挂起。最后如果以上都失败就升级为重量级锁
                            锁只能升级，不能降级
                特性保证
                    原子性
                        单一线程持有，确保同一时间只有一个线程能拿到锁
                    可见性
                        内存强制刷新
                    有序性
                        as-if-serial
                        happens-before
                    可重入性
                        计数器
                            synchronized锁对象的时候有个计数器，他会记录下线程获取锁的次数，在执行完对应的代码块之后，计数器就会-1，直到计数器清零，就释放锁了
                    不可中断性
                        一个线程获取锁之后，另外一个线程处于阻塞或者等待状态，前一个不释放，后一个也一直会阻塞或者等待，不可以被中断
                        PS：Lock的tryLock方法是可以被中断的
            信号量volatile信号量模型
                使用场景
                    线程修改的可见性要求
                    作为触发器，轻量级同步
                JMM
                    特性
                        原子性
                            JMM只能保证基本的原子性，如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的
                        可见性
                            可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改了
                                volatile
                                    volatile关键字可以保证直接从主存中读取一个变量，如果这个变量被修改后，总是会被写回到主存中去
                                synchronized
                                    不管怎么重排序，单线程下的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义
                                final
                                    被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去，那么在其他线程就能看见final字段的值（无须同步）
                        有序性
                            重排序
                                为了提高性能，编译器和处理器常常会对既定的代码执行顺序进行指令重排序。
                                分类
                                    编译器重排序，指令级并行的重排序，内存系统重排序
                                as-if-serial
                            可以使用synchronized或者volatile保证多线程之间操作的有序性
                            volatile
                                volatile关键字是使用内存屏障达到禁止指令重排序，以保证有序性
                                    volatile写是在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障
                                    happens-before
                                        如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系
                            synchronized
                                一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized包住的代码块在多线程之间是串行执行的
                    JavaMemoryModel--Java内存模型：规范
                        高速缓存
                        主内存
                    缓存一致性（CacheCoherence）
                        在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存
                        为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol等
                        MESI
                            缓存一致性协议
                            当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取
                    8种内存交互操作
                总结
                    volatile属性的读写操作都是无锁的，
                    volatile阻止属性重排序
                    volatile提供了可见性
                    volatile提供了happens-before保证，对volatile变量v的写入happens-before所有其他线程后续对v的读操作
                    volatile可以使得long和double的赋值是原子的
                    volatile可以在单例双重检查中实现可见性和禁止指令重排序，从而保证安全性
        可重入锁
        管道
            PipedWriter
             PipedReader 
            PipedOutputSteam 
            PipedInputSteam
        算法
            资源分配图(RAG)
            哲学家就餐问题
        死锁四个条件
    对比
        synchronized的volatile区别
            修饰对象不同
            不能替换sync
            volatile保证数据的可见性，但是不保证原子性；而synchronized是一种排他(互斥)的机制
            volatile可以看做是轻量版的synchronized
        sync和lock的区别
            功能
                Lock可以使用读锁提高多线程读效率
                可以尝试获取锁
                不同范围、不同顺序获取和释放锁
                公平
                    synchronized是非公平锁，ReentrantLock可以控制是否是公平锁
                观测
                    通过Lock可以知道线程有没有拿到锁，而synchronized不能
                中断
                    synchronized是不可中断的，Lock可以中断也可以不中断
                释放
                    synchronized会自动释放锁，而Lock必须手动释放锁
            原理
                synchronized是关键字，是JVM层面的；而Lock是一个接口，是JDK层面的有丰富的API
            使用对象
                synchronized能锁住方法和代码块，而Lock只能锁住代码块
        sync和reentrant区别
            都是独占锁而且可重入
            synchronized不可响应中断
            ReentrantLock还可以实现公平锁机制
    悲观锁
        Lock接口
            Lock
                加锁，如果锁已经被别人占用了，就无限等待
                大规模得在复杂场景中使用，是有可能因此死锁的
            ReentrantLock可重入锁
                作用：解决死锁，可以反复枷锁
                可以获取锁的等待时间，避免死锁
                获取各种锁的信息
                灵活实现多路通知
                底层调用Unsafe的park方法加锁
                boolean tryLock  尝试获取锁 
                    相较于lock()好处
                        可以不用进行无限等待
                        可以在应用程序这层进行进行自旋，你可以自己决定尝试几次，或者是放弃
                        等待锁的过程中可以响应中断
                    boolean tryLock()
                重入锁的原理
                    reentrantLock.lock()
                        ReentrantLock(boolean fair)---sync = fair ? new FairSync() : new NonfairSync()
                        默认不公平，随机
                            ReentrantLock()---sync = new NonfairSync()
                        公平/不公平区别：
                            公平锁是有代价的：维持公平竞争是以牺牲系统性能为代价的
                            非公平锁会调用compareAndSetState()，试图抢占，如果第一次争抢失败，后面的处理和公平锁是一样的，都是进入等待队列慢慢等
                    AQS队列同步器
                        定义状态变量state
                        等待则进入condition等待队列
                        当condition条件满足时，出队继续竞争
            读写锁
                说明
                    和互斥锁相比，ReentrantReadWriteLock就是读线程和读线程之间不互斥
                    读读不互斥，读写互斥，写写互斥
                类继承层次
                    Lock
                    ReadWriteLock
                        一个接口，内部由两个Lock接口组成
                            readLock()
                            writeLock()
                    ReentrantReadWriteLock
                        实现了ReadWriteLock接口
                        当使用ReadWriteLock时，并不是直接使用，而是获得其内部的读锁和写锁，然后分别调用lock/unlock
                实现原理
                    表面上看，ReadLock和WriteLock是两把锁，但实际上它只是一把锁的两个视图而已
                    readerLock和writerLock实际上公用同一个sync对象，它同互斥锁一样，分为非公平/公平两种策略，并继承自AQS
                    读写锁也用state变量来表示锁状态，在内部类Sync中，对state变量进行了重新定义，即把state变量拆成两半
                        低16位，用来记录写锁
                        高16位，用来“读”锁
                    因为无法用一次CAS同时操作两个int变量，所以用一个int变量的高低16位分别表示读锁和写锁的状态
                    state=0，说明既没有线程持有读写，也没有线程持有写锁
                    当state!=0，要么有线程持有读锁，要么有线程持有写锁，两者不能同时成立，因为读写互斥
                AQS的两对模板方法
                    方法
                        acquire()/release()
                            互斥锁和读写锁的写锁基本这两个方法实现
                        acquireShared()/releaseShared()
                            读写锁的读锁基于这两个方法实现
                    实现
                        读锁的公平实现
                            Sync.tryAccquireShared()  + FairSync中的两个重写的子方法
                        读锁的非公平实现
                            Sync.tryAccquireShared()  + NonfairSync中的两个重写的子方法
                        写锁的公平实现
                            Sync.tryAccquire()  + FairSync中的两个重写的子方法
                        写锁的非公平实现
                            Sync.tryAccquire()  + NonfairSync中的两个重写的子方法
                    说明
                        公平
                            不论是读锁/写锁，只要队列中有其他线程在排队，就不能直接去抢锁，要排在队列尾部
                        非公平
                            写锁
                                写线程能抢锁，前提是state=0，只有在没有其他线程持有读锁/写锁的情况下，它才有机会去抢锁
                                或者state!=0，而持有写锁的线程是自己，再次重入
                                写线程是非公平的，即writerShouldBlock()一直返回false
                            读锁
                                假设当前线程被读线程持有，然后其他读线程非公平地去抢，可能导致写线程永远拿不到锁，所以对于读线程的非公平，需要做一些“约束”
                                当发现队列的第一个元素是写线程时，读线程也要阻塞，不能直接去抢
                WriteLock实现
                    写锁是排他锁，实现策略类似于互斥锁
                    tryLock()
                        当state不是0，如果写线程获取锁的个数为0，或写线程不是当前线程，则返回抢锁失败
                        只要不是以上情况，则通过CAS设置state值，如果成功，就将排他线程设置为当前线程，返回true
                        tryLock()和lock()不区分公平/非公平
                    unlock()
                        不区分公平/非公平
                ReadLock实现
                    读锁是共享锁，实现策略和排他锁有很大差异
                    tryLock()
                        如果写线程占用锁或当前线程不是排他线程，则抢锁失败
                        如果获取锁的值达到极限，则抛异常
                        使用CAS设置读线程锁的state值，如果成功
                            如果第一个读线程就是当前线程，表示读线程重入读锁
                            如果不是当前线程，则从ThreadLocal中获取当前线程的读锁个数，并设置当前线程持有的读锁个数
                    unlock()
                        因为读锁是共享锁，多个线程会同时持有读锁，所以对读锁的释放不能直接减1，而是需要通过一个for循环+CAS操作不断重试
            StampedLock
                引入原因
                    StampedLock是JDK8中新增的，从ReentrantLock到StampedLock，并发度依次提高
                    StampedLock引入了“乐观读”策略，读时不加读锁，读出来发现数据被修改了，再升级为“悲观读”，相当于降低了读的地位，避免写线程被饿死
                    StampedLock读读不互斥，读写不互斥，写写互斥
                使用场景
                “乐观读”实现原理
                    state
                        StampedLock是一个读写锁，因为也会像读写锁一样，把state拆分，分别表示读锁和写锁的状态
                        同时它需要一个数据的version，但一次CAS没办法操作两个变量，所以这个state本身还表示了数据的version
                        最低的8位表示读和写的状态，第8位表示写锁状态，低7位表示读锁状态，因为写锁只有一个bit位，所以写锁不可重入
                        初始值不为0
                悲观读/写
                    StampedLock也要进行悲观的读锁和写锁操作，但它不是基于AQS实现，而是内部重新实现了一个阻塞队列
                    阻塞队列实现锁的调用策略和AQS不一样
                        AQS中，一个线程CAS_state失败后，会立即加入阻塞队列，并进入阻塞状态
                        StampedLock中，CAS_state失败后，会不断自旋，直到足够多次数后，如果还拿不到锁，才进入阻塞状态
                        为此根据CPU的核数，定义了自旋次数的常量值
                    acquireWrite()
                        两个大的for循环，内部实现了非常复杂的自旋策略
                        第一个循环中，目的就是把Node加入队列的尾部，一边加入，一边通过CAS操作尝试获得锁
                            如果获得，则整个方法返回
                            如果不能获得，会一直自旋，直到加入队列尾部
                        第二个循环中，即该Node已经在队列尾部
                            这时如果发现自己也在队列头部，说明队列除了空的Head节点，就是当前线程
                            此时再进行一轮自旋，直到达到MAX_HEAD_SPINS，然后进入阻塞
                    另一个不同于AQS阻塞队列的是，在每个WNode里有一个cowait指针，用于串联起所有读线程，这样一个读线程被唤醒，其他读线程会随之一同唤醒，因为读读不互斥
        synchronized
            控制线程同步
            一段代码、方法、变量加锁
            关键字
            加锁操作的对象头中的markword
            悲观锁，抢占式，引起其他线程阻塞
    乐观锁
        CAS
            JUC工具类
                AtomicInteger
                    自增函数incrementAndGet()，判断偏移量是否一致do，里面用的do-while循环，不成功一直循环
                AtomicReference
                    可以用来保证对象之间的原子性，就可以把多个对象放入CAS中操作
                    项目实践
                        在很多订单表，流水表，为了防止并发问题，就会加入CAS的校验过程，保证了线程的安全，但是看场景使用，并不是适用所有场景，他的优点缺点都很明显
            原理
                存在的问题
                    ABA
                        cas比较过程中，数据被其他线程更改又改回来了
                        解决
                            加标志位，如版本号、时间戳、自增长字段
                                svn提交代码，版本号不一致会冲突
                    循环时间长，开销大
                        cas比较一直失败，会一直自旋，CPU压力大
                    只能保证一个变量的原子操作
                怎么实现线程安全
                    比较+更新，整体是一个原子操作
                        举例：一个线程修改订单的状态（待支付-->已支付），修改前判断状态是不是待支付，如果没有被其他线程修改状态则更新，如果修改了则重新查询
    锁的执行原理
        创建对象锁
    锁的分类
        线程要不要锁住同步资源
            锁住
            悲观锁
                操作资源时候持有独占锁
                并发操作线程乐观，比较和替换操作放在修改内存变量中
            不锁住
        多线程能否共享一把锁
            可以共享
                共享锁
            不可以共享
                独占锁
        多个线程竞争时，是否需要排队
            需要
                公平锁
            不需要
                非公平锁
        同一个线程是否可以重复获取一把锁
            可以
                可重入锁
            不可以
                不可重入锁
        是否可以中断
            可以
                可中断锁
            不可以
                不可中断锁
        等锁的过程
            自旋锁：不停的去尝试获取锁
            非自旋锁：阻塞型的
        JDK1.6之后引入偏向锁和轻量级锁的概念：锁优化
            偏向锁
            偏向锁升级轻量级锁
            轻量级锁
            重量级锁
                objectMonitor
    lock包
        Lock/Condition
            互斥锁
                锁的可重入性
                    可重入锁指当一个线程调用oject.lock()获取到锁，进入临界区后，再次调用object.lock()，仍然可以获取到锁
                    通常锁都要设计成可重入的，否则就会发生死锁，synchronized就是可重入锁
                类继承层次
                    Lock
                        一个接口，常用方法是lock/unlock()
                        lock()不能被中断，对应的lockInterruptibly()可以被中断
                    ReentrantLock
                        本身没有代码逻辑，实现都在内部类Sync中
                        Sync
                            AbstractQueuedSynchronizer
                        NonfairSync
                        FairSync
                锁的公平性/非公平性
                    说明
                        Sync是一个抽象类，有两个子类FairSync/UnfairSync，分别对应公平锁和非公平锁
                        ReentrantLock构造方法中，可以传入一个布尔类型变量fair指定锁是否公平，默认非公平
                        一个新的线程来了，看到有很多线程在排队，自己排到队伍末尾，这叫公平锁，线程来了之后直接去抢锁，这叫做不公平
                        默认设置是非公平锁，是为了提高效率，减少线程切换
                    基本实现原理
                        Sync的父类AbstractQueuedSynchronizer被称作队列同步器（AQS），它的父类是AbstractOwnableSynchronizer
                        为了实现一把具有阻塞或唤醒作用的锁，需要几个核心要素
                            1、需要一个state变量，标记锁的状态
                                至少有两个值：0，1
                                对state的操作，使用CAS保证线程安全
                            2、需要记录当前是哪个线程持有锁
                            3、需要底层支持对一个线程进行阻塞或唤醒操作
                            4、需要有一个队列维护所有阻塞的线程
                                这个队列必须是线程安全的无锁队列，也需要使用CAS
                        AQS的state取值不仅可以是0/1，还可以大于1，就是为了支持锁的可重入性
                        Unsafe类提供了阻塞或唤醒线程的一对操作原语，即park()/unpark()，LockSupport工具类对这对原语做了简单封装
                            在当前线程中调用park()，该线程会被阻塞，在另外一个线程中调用unpark(Thread)，传入一个阻塞的线程，就可以唤醒阻塞在park()处的线程
                            unpark(Thread)实现了一个线程对另一个线程的精准唤醒，而notify只是唤醒某一个线程，但无法指定具体唤醒哪个线程
                        AQS中利用双向链表和CAS实现了一个阻塞队列
                            它是整个AQS的核心中的核心
                                head指向链表头部，tail指向链表尾部
                                入队就是把新的Node加到tail后面，然后对tail进行CAS操作
                                出队就是对head进行CAS操作，把head向后移一个位置
                                初始时，head=tail=null，然后在往队列中加入阻塞线程时，会新建一个空的Node，让head和tail都指向这个空Node，之后在后面加入被阻塞的线程对象
                公平/非公平锁实现差异
                    非公平
                        如果state为0，直接将当前线程设置为排他线程，同时设置state的值
                        如果state不为0，但是排他线程就是当前线程，则直接设置state的值
                        否则返回false，获取失败
                    公平
                        如果state为0，且队列中没有等待的线程，则设置当前线程为排他线程，并设置state的值
                        如果state不为0，但是排他线程就是当前线程，则直接设置state的值
                        否则返回false，获取失败
                阻塞队列/唤醒机制
                    addWaiter()
                        为当前线程生成一个Node，然后把Node放入链表尾部
                        此时只是把Thread对象放入一个队列而已，线程本身并未阻塞
                        之后工作依靠acquireQueued()完成
                    acquireQueued()
                        线程一旦进入方法就会被无限期阻塞，即使有其他线程调用inerrupt()也不能将其唤醒，除非有其他线程释放了锁，且该线程拿到了锁，才会从该方法返回
                        方法返回的一刻，即拿到锁/被唤醒时，会删除队列的第一个元素，head指针前移1个节点
                        该方法不会中断响应，但它会记录被阻塞期间有没有其他线程向它发送过中断信号，如果有，返回true，否则返回false
                        该方法返回true时，会调用selfInterrupt()，自己给自己发送中断信号，即自己把自己的中断标志位设为true
                            这样做是因为自己在阻塞期间，收到其他线程中断信号没有及时响应，现在要进行补偿
                            这样，如果该线程在lock代码块内部有调用sleep()之类阻塞方法，就可以抛出异常，响应该中断信号
                    parkAndCheckInterrupt()
                        阻塞发生在该方法中，线程调用park()，自己把自己阻塞起来，直到被其他线程唤醒，该方法返回
                        park()返回情况
                            1、其他线程调用了unpark(Thread)
                            2、其他线程调用了t.interrupt()
                                注意lock()不能响应中断，但LockSupport.park()能响应中断
                        因为LockSupport.park()可能被中断唤醒，accquireQueued()才写了一个for死循环，唤醒之后，如果发现自己排在队列头部，就去拿锁，如果拿不到，就再次自己阻塞自己，不断重复此过程，直到拿到锁
                        被唤醒后，通过Thread.interrupted()来判断是否被中断唤醒
                unlock()
                    unlock()不区分是否公平，内部直接调用sync.release()
                    release()
                        当前线程要释放锁，先调用tryRelease()，如果返回true，则取出head，让head获取锁
                    tryRelease()
                        先计算当前线程释放锁后的state值
                        如果当前线程不是排他线程，则抛异常，因为只有获取锁的线程才可以释放锁
                        此时设置state，没有使用CAS，因为是单线程操作
                    unparkSuccessor()
                        唤醒队列中的后继者
                lockInterruptibly()
                    可以被中断，直接调用sync.acquireInterruptibly()
                    acquireInterruptibly()
                        AQS的模板方法，内部的tryAcquire()分别被FairSync/UnfairSync实现
                    doAcquireInterruptibly()
                        当parkAndCheckInterrupt)返回true，说明有其他线程发送中断信号，直接抛出InterruptedException，跳出for循环，整个方法返回
                tryLock()
                    实现基于调用非公平锁的tryAcquire()，对state进行CAS操作，如果成功就拿到锁，如果不成功则直接返回false，也不阻塞
            Condition
                与Lock的关系
                    Condition本身也是一个接口，其功能和wait()/notify()类似
                    Condition必须和Lock一起使用，因此Lock接口中，有一个与Condition相关的接口
                实现原理
                    由于Condition必须和Lock一起使用，所以Condition的实现也是Lock的一部分
                    读写锁中的ReadLock不支持Condition，读写锁的WriteLock和互斥锁都支持Condition
                    每一个Condition对象上，都阻塞了多个线程，所以在ConditionObject内部也有一个双向链表组成的队列
                await()
                    关键点说明
                        1、线程调用await()时，肯定已经拿到了锁
                            所以addConditionWaiter()内部，对这个双向链表的操作不需要执行CAS操作，线程天生是安全的
                        2、在线程执行wait操作前，必须先释放锁
                            即fullyRelease(Node)，否则会发生死锁
                        3、线程从wait中被唤醒后，必须用acquireQueued(node,saveState)重新拿锁
                        4、checkInterruptWhileWaiting(node)在park()之后，是为了检测在park期间是否受到过中断信号
                            当线程从park中醒来，有两种可能
                                一是其他线程调用了unpark
                                另一是收到中断信号
                            await()是可以响应中断的，所以当发现自己是被中断唤醒，会直接退出while循环，然后返回
                        5、isOnSyncQueue(node)用于判断该Node是否在AQS的同步队列中
                            初始时，Node只在Condition队列中，而不在AQS队列里
                            但执行notify()操作时，会放进AQS的同步队列
                awaitUninterruptibly()
                    不会响应中断，其方法定义中不会有中断异常抛出
                    当线程唤醒后，如果被中断过，仅记录不处理，继续进行while循环
                notify()
                    同await()一样，调用notify()时，必须先拿到锁（否则会抛出异常），因为前面执行await()时，把锁释放了
                    然后从队列中取出firstWaiter，唤醒它，在通过调用unpark()唤醒前，先用enq(node)把这个Node放入AQS的锁对应的阻塞队列中
        java.util.concurrent.locks.lock接口
            自旋锁
            ReentrantLock（可重入锁）
            ReadWriteLock
                读锁
                    共享锁
                写锁
                    独享锁
            可指定是公平锁还是非公平锁
            继承AbstractQueuedSynchronizer（AQS）
            condition
                await（）
                signal()
                signaAlll()
共享锁
独享锁